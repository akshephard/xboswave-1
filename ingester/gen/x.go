package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/emicklei/proto"
)

var toparse []string
var subfields [][]string
var parsefields = make(map[string][]string)
var parsesubfields = make(map[string][]string)
var parseunits = make(map[string]string)
var f = NewFile("x")
var d = make(Dict)
var unitsd = make(Dict)
var unitdefre = regexp.MustCompile(`unit:\s*([a-zA-Z0-9_\-/%# ]+)`)

func main() {
	f.PackageComment("This file is AUTOGENERATED")
	f.ImportAlias("github.com/gtfierro/wavemqingester/proto", "xbospb")
	files := []string{
		"proto/xbos.proto",
		"proto/hamilton.proto", // TODO: load this from xbos imports
		"proto/iot.proto",      // TODO: load this from xbos imports
	}
	for _, filename := range files {
		reader, _ := os.Open(filename)
		defer reader.Close()

		parser := proto.NewParser(reader)
		definition, _ := parser.Parse()

		proto.Walk(definition,
			proto.WithMessage(handleMessage),
		)
		proto.Walk(definition,
			proto.WithMessage(handleMessage2),
		)
	}
	fmt.Println(toparse)

	fmt.Println("-------------")
	for fieldname, subfields := range parsefields {
		for _, subfieldname := range subfields {
			fmt.Println(fieldname, subfieldname)
		}
	}
	fmt.Println("-------------")
	for fieldname, subfields := range parsesubfields {
		for _, subfieldname := range subfields {
			fmt.Println("sub>", fieldname, subfieldname)
		}
	}
	f.Var().Id("lookup").Op("=").Map(String()).Func().Params(
		Id("msg").Id("xbospb").Dot("XBOS"),
	).Float64().Values(d)
	f.Var().Id("units").Op("=").Map(String()).String().Values(unitsd)

	fmt.Printf("%#v\n", f)
}

func handleService(s *proto.Service) {
	fmt.Println(s.Name)
}
func handleOption(s *proto.Option) {
	fmt.Println(s.Name)
}

var scalartypes = []string{
	"double",
	"float",
	"int32",
	"int64",
	"uint32",
	"uint64",
	"bool",
}

var disallowed = []string{
	"string",
	"bytes",
}

func contains(l []string, v string) bool {
	for _, s := range l {
		if s == v {
			return true
		}
	}
	return false
}

func handleMessage(m *proto.Message) {
	fmt.Println("Message:", m.Name, len(m.Elements), m.Parent.(*proto.Proto).Filename)

	for _, v := range m.Elements {
		f := v.(*proto.NormalField)
		fmt.Println(f.Name, f.Type, f.Doc())
		if f.Doc() != nil {
			lines := f.Doc().Lines
			// This looks for every comment line above a field definition
			// for a line starting with 'unit:'. Everything after 'unit:'
			// will be considered the engineering units for this field.
			// Valid characters are: a-zA-Z0-9_/%# and '-' and space.
			// Whitespace is stripped from the unit field.
			//
			//   //this is the unit temperature
			//   //unit: celsius
			//   //double temperature = 1;
			//
			parseunits[f.Name] = "unknown"
			for _, l := range lines {
				ud := pullUnitDef(l)
				if ud != "unknown" {
					parseunits[f.Name] = ud
					break

				}
			}
		}

		// keep track of the top-level messages in other files that we want to parse
		if m.Name == "XBOS" {
			toparse = append(toparse, f.Name)
		} else {

			// otherwise, keep track of the field path
			//if contains(toparse, m.Name) {
			if contains(scalartypes, f.Type) {
				fmt.Println("extract", m.Name, ".", f.Name)
				//subfields = append(subfields, []string{m.Name})
				parsefields[m.Name] = append(parsefields[m.Name], f.Name)
			} else if !contains(disallowed, f.Type) {
				fmt.Println("subtype", m.Name, ".", f.Name, f.Type)
				parsesubfields[f.Name] = append(parsefields[f.Name], f.Type)
			}
		}
		//}

	}

}

func handleMessage2(m *proto.Message) {

	if contains(toparse, m.Name) {
		fmt.Println("Parse fields in", m.Name)

		for _, v := range m.Elements {
			field := v.(*proto.NormalField)
			propname := field.Name // key
			if contains(parsefields[m.Name], propname) {
				fmt.Println("  parsing", propname)
				protofield := strings.Replace(strings.Title(strings.Replace(propname, "_", " ", -1)), " ", "", -1)
				d[Lit(propname)] = Func().Params(
					Id("msg").Id("xbospb").Dot("XBOS"),
				).Float64().Block(
					Return(
						Float64().Call(Id("msg").Dot(m.Name).Dot(protofield)),
					),
				)
				unitsd[Lit(propname)] = Lit(parseunits[propname])
			} else if contains(parsesubfields[propname], field.Type) {
				for _, subfield := range parsefields[field.Type] {
					fmt.Println("  parsing", propname, ".", subfield)
					protofield := strings.Replace(strings.Title(strings.Replace(propname, "_", " ", -1)), " ", "", -1)
					subprotofield := strings.Replace(strings.Title(strings.Replace(subfield, "_", " ", -1)), " ", "", -1)

					unitsd[Lit(subfield)] = Lit(parseunits[subfield])

					d[Lit(subfield)] = Func().Params(
						Id("msg").Id("xbospb").Dot("XBOS"),
					).Float64().Block(
						Return(
							Float64().Call(Id("msg").Dot(m.Name).Dot(protofield).Dot(subprotofield)),
						),
					)
				}
			}
		}
	} else {
		fmt.Println("NO PARSE", m.Name)
	}
	return
}

func pullUnitDef(s string) string {

	groups := unitdefre.FindStringSubmatch(s)
	if len(groups) > 1 {
		return groups[1]
	}
	return "unknown"
}
