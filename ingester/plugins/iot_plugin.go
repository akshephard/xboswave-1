// This file is AUTOGENERATED
package main

import "github.com/gtfierro/xboswave/ingester/types"
import xbospb "github.com/gtfierro/xboswave/proto"
import "fmt"

func has_meter(msg xbospb.XBOS) bool {
	if msg.XBOSIoTDeviceState == nil {
		return false
	}
	return msg.XBOSIoTDeviceState.Meter != nil
}

func has_light(msg xbospb.XBOS) bool {
	if msg.XBOSIoTDeviceState == nil {
		return false
	}
	return msg.XBOSIoTDeviceState.Light != nil
}

var lookup = map[string]func(msg xbospb.XBOS) (float64, bool){
	"apparent_power": func(msg xbospb.XBOS) (float64, bool) {
		if has_meter(msg) && msg.XBOSIoTDeviceState.Meter.ApparentPower != nil {
			return float64(msg.XBOSIoTDeviceState.Meter.ApparentPower.Value), true
		}
		return 0, false
	},
	"power": func(msg xbospb.XBOS) (float64, bool) {
		if has_meter(msg) && msg.XBOSIoTDeviceState.Meter.Power != nil {
			return float64(msg.XBOSIoTDeviceState.Meter.Power.Value), true
		}
		return 0, false
	},
	"voltage": func(msg xbospb.XBOS) (float64, bool) {
		if has_meter(msg) && msg.XBOSIoTDeviceState.Meter.Voltage != nil {
			return float64(msg.XBOSIoTDeviceState.Meter.Voltage.Value), true
		}
		return 0, false
	},

	"brightness": func(msg xbospb.XBOS) (float64, bool) {
		if has_light(msg) && msg.XBOSIoTDeviceState.Light.Brightness != nil {
			return float64(msg.XBOSIoTDeviceState.Light.Brightness.Value), true
		}
		return 0, false
	},
	"state": func(msg xbospb.XBOS) (float64, bool) {
		if has_light(msg) && msg.XBOSIoTDeviceState.Light.State != nil {
			if msg.XBOSIoTDeviceState.Light.State.Value {
				return 1, true
			} else {
				return 0, true
			}
		}
		return 0, false
	},

	//	"charging_time_left": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Evse.ChargingTimeLeft.Value)
	//	},
	//	"current": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Evse.Current.Value)
	//	},
	//	"current_limit": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Evse.CurrentLimit.Value)
	//	},
	//	"enabled_cool_stages": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Thermostat.EnabledCoolStages)
	//	},
	//	"enabled_heat_stages": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Thermostat.EnabledHeatStages)
	//	},
	//	"fan_state": func(msg xbospb.XBOS) (float64, bool) {
	//		if msg.XBOSIoTDeviceState.Thermostat.FanState {
	//			return 1
	//		} else {
	//			return 0
	//		}
	//	},
	//	"override": func(msg xbospb.XBOS) (float64, bool) {
	//		if msg.XBOSIoTDeviceState.Thermostat.Override {
	//			return 1
	//		} else {
	//			return 0
	//		}
	//	},
	//	"relative_humidity": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Thermostat.RelativeHumidity)
	//	},
	//	"requestid": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Requestid)
	//	},
	//	"temperature": func(msg xbospb.XBOS) (float64, bool) {
	//		return float64(msg.XBOSIoTDeviceState.Thermostat.Temperature)
	//	},
}

var units = map[string]string{
	"apparent_power":      "kVA",
	"brightness":          "percent",
	"charging_time_left":  "seconds",
	"current":             "A",
	"current_limit":       "A",
	"enabled_cool_stages": "unknown",
	"enabled_heat_stages": "unknown",
	"fan_state":           "t/f",
	"override":            "t/f",
	"power":               "kW",
	"relative_humidity":   "% rh",
	"requestid":           "unknown",
	"state":               "on/off",
	"temperature":         "celsius",
	"voltage":             "V",
}

func build(uri types.SubscriptionURI, name string, msg xbospb.XBOS) types.ExtractedTimeseries {

	if extractfunc, found := lookup[name]; found {
		if value, found := extractfunc(msg); found {
			var extracted types.ExtractedTimeseries
			time := int64(msg.XBOSIoTDeviceState.Time)
			extracted.Values = append(extracted.Values, value)
			extracted.Times = append(extracted.Times, time)
			extracted.UUID = types.GenerateUUID(uri, []byte(name))
			extracted.Collection = fmt.Sprintf("xbos/%s", uri.Resource)
			extracted.Tags = map[string]string{
				"unit": units[name],
				"name": name,
			}
			return extracted
		}
	}

	return types.ExtractedTimeseries{}
}

func Extract(uri types.SubscriptionURI, msg xbospb.XBOS, add func(types.ExtractedTimeseries) error) error {
	if msg.XBOSIoTDeviceState != nil {
		for _, name := range []string{"state", "brightness"} {
			extracted := build(uri, name, msg)
			if err := add(extracted); err != nil {
				return err
			}
		}
	}
	return nil
}
